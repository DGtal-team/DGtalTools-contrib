/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file vol2offAndNormals.cpp
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/03/20
 *
 * Computes the surfel surface as an off and its estimated normals.
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include "CLI11.hpp"
#ifdef WITH_VISU3D_QGLVIEWER
#include "DGtal/io/viewers/Viewer3D.h"
#endif
#include "DGtal/base/Common.h"
#include "DGtal/base/BasicFunctors.h"
#include "DGtal/helpers/StdDefs.h"
#include "DGtal/kernel/BasicPointPredicates.h"
#include "DGtal/topology/helpers/Surfaces.h"
#include "DGtal/topology/DigitalSurface.h"
#include "DGtal/topology/SetOfSurfels.h"
#include "DGtal/topology/ImplicitDigitalSurface.h"
#include "DGtal/math/linalg/EigenDecomposition.h"
#include "DGtal/images/ImageContainerBySTLVector.h"
#include "DGtal/images/ImageSelector.h"
#include "DGtal/images/IntervalForegroundPredicate.h"
#include "DGtal/geometry/volumes/distance/ExactPredicateLpSeparableMetric.h"
#include "DGtal/geometry/volumes/distance/VoronoiMap.h"
#include "DGtal/geometry/volumes/distance/DistanceTransformation.h"
#include "DGtal/geometry/volumes/estimation/VoronoiCovarianceMeasure.h"
#include "DGtal/geometry/surfaces/estimation/LocalEstimatorFromSurfelFunctorAdapter.h"
#include "DGtal/geometry/surfaces/estimation/estimationFunctors/ElementaryConvolutionNormalVectorEstimator.h"
#include "DGtal/geometry/surfaces/estimation/VoronoiCovarianceMeasureOnDigitalSurface.h"

#include "DGtal/io/readers/GenericReader.h"
#include "DGtal/io/colormaps/GradientColorMap.h"

using namespace std;

typedef DGtal::Z3i::Space Space;
typedef DGtal::Z3i::KSpace KSpace;
typedef DGtal::Z3i::Vector Vector;
typedef DGtal::Z3i::Point Point;
typedef DGtal::Z3i::RealPoint RealPoint;
typedef DGtal::Z3i::RealVector RealVector;
typedef DGtal::HyperRectDomain<Space> Domain;
typedef DGtal::ImageContainerBySTLVector<Domain,bool> CharacteristicSet;
typedef DGtal::ExactPredicateLpSeparableMetric<Space, 2> Metric; // L2-metric
typedef DGtal::EigenDecomposition<3,double> LinearAlgebraTool;
typedef LinearAlgebraTool::Matrix Matrix33;
typedef LinearAlgebraTool::Vector Vector3;
typedef KSpace::Surfel Surfel;
typedef KSpace::SCell SCell;

template <typename Surface>
bool exportSteppedSurfaceAsOff( std::ostream& output,
                                const Surface& surface )
{
  typedef typename Surface::KSpace        KSpace;
  typedef typename Surface::ConstIterator ConstIterator;
  typedef typename KSpace::SCell          SCell;
  typedef typename KSpace::Cell           Cell;
  typedef typename KSpace::Point          Point;
  typedef typename KSpace::DirIterator    DirIterator;
  // Enumerating faces, edges, vertices
  std::set<Cell> edges;
  std::set<Cell> vertices;
  const KSpace& K  = surface.container().space();
  for ( ConstIterator it = surface.begin(), itE = surface.end(); it != itE; ++it )
    {
      SCell surfel  = *it;
      Cell  face    = K.unsigns( surfel );
      DirIterator q = K.sDirs( *it );
      DGtal::Dimension i0 = *q; ++q;
      DGtal::Dimension i1 = *q;
      Cell  edge0f = K.uIncident( face, i0, false );
      Cell  edge0t = K.uIncident( face, i0, true );
      Cell  edge1f = K.uIncident( face, i1, false );
      Cell  edge1t = K.uIncident( face, i1, true );
      edges.insert( edge0f );
      edges.insert( edge0t );
      edges.insert( edge1f );
      edges.insert( edge1t );
      Cell vtx00   = K.uIncident( edge0f, i1, false );
      Cell vtx01   = K.uIncident( edge0f, i1, true );
      Cell vtx10   = K.uIncident( edge0t, i1, false );
      Cell vtx11   = K.uIncident( edge0t, i1, true );
      vertices.insert( vtx00 );
      vertices.insert( vtx01 );
      vertices.insert( vtx10 );
      vertices.insert( vtx11 );
    }
  unsigned int nbf = surface.size();
  unsigned int nbe = edges.size();
  unsigned int nbv = vertices.size();

  // numbering vertices and outputing vertices coordinates
  output << "OFF" << std::endl
         << "# Generated by DGtal::vol2offAndNormals." << std::endl
         << nbv << " " << nbf << " " << nbe << std::endl;
  unsigned int idx = 0;
  std::map<Cell,unsigned int> vtx2index;
  for ( typename std::set<Cell>::const_iterator it = vertices.begin(), itE = vertices.end(); it != itE; ++it )
    {
      vtx2index[ *it ] = idx++;
      Point x = K.uCoords( *it );
      output << x[ 0 ] << " " << x[ 1 ] << " "<< x[ 2 ] << std::endl;
    }
  // outputing faces with correct orientation
  for ( ConstIterator it = surface.begin(), itE = surface.end(); it != itE; ++it )
    {
      SCell surfel        = *it;
      DGtal::Dimension k  = K.sOrthDir( surfel );
      bool k_direct       = K.sDirect( surfel, k );
      SCell v_in          = K.sIncident( surfel, k, k_direct );
      SCell v_out         = K.sIncident( surfel, k, ! k_direct );
      Point out_normal    = K.sCoords( v_out ) - K.sCoords( v_in );
      Cell  face          = K.unsigns( surfel );
      DirIterator q       = K.sDirs( *it );
      DGtal::Dimension i0 = *q; ++q;
      DGtal::Dimension i1 = *q;
      Cell  edge0f        = K.uIncident( face, i0, false );
      Cell  edge0t        = K.uIncident( face, i0, true );
      Cell vtx00          = K.uIncident( edge0f, i1, false );
      Cell vtx01          = K.uIncident( edge0f, i1, true );
      Cell vtx10          = K.uIncident( edge0t, i1, false );
      Cell vtx11          = K.uIncident( edge0t, i1, true );
      // Forming normal vector
      Point v00_01        = K.uCoords( vtx01 ) - K.uCoords( vtx00 );
      Point v01_11        = K.uCoords( vtx11 ) - K.uCoords( vtx01 );
      Point cur_normal    = v00_01.crossProduct( v01_11 );
      output << "4 " << vtx2index[ vtx00 ] << " ";
      if ( cur_normal.dot( out_normal ) > 0 )
        output << vtx2index[ vtx01 ] << " " << vtx2index[ vtx11 ] << " " << vtx2index[ vtx10 ] << std::endl;
      else
        output << vtx2index[ vtx10 ] << " " << vtx2index[ vtx11 ] << " " << vtx2index[ vtx01 ] << std::endl;
    }
}

template <typename Viewer, typename Surface, typename KernelFunction>
void computeSurfaceVCM( Viewer& viewer,
                        std::string basename,
                        const Surface & surface, 
                        double R, double r,
                        KernelFunction chi,
                        double trivial_r, int embedding )



{
  typedef typename Surface::DigitalSurfaceContainer DigitalSurfaceContainer;
  BOOST_CONCEPT_ASSERT(( DGtal::concepts::CDigitalSurfaceContainer<DigitalSurfaceContainer> ));
  using namespace DGtal;
  typedef typename Surface::KSpace                  KSpace; 
  typedef typename KSpace::Space                    Space;
  typedef typename Surface::Surfel                  Surfel;
  typedef typename Surface::Cell                    Cell;
  typedef typename Space::Point                     Point;
  typedef typename Space::RealPoint                 RealPoint;
  typedef typename Space::RealVector                RealVector;
  typedef ExactPredicateLpSeparableMetric<Space, 2> Metric; // L2-metric
  typedef VoronoiCovarianceMeasure< Space, Metric > VCM;
  typedef typename VCM::Domain                      Domain;
  typedef typename Surface::ConstIterator           SurfelConstIterator;
  typedef VoronoiCovarianceMeasureOnDigitalSurface
    < DigitalSurfaceContainer, Metric, KernelFunction > VCMOnSurface;
  typedef typename VCMOnSurface::VectorN            VectorN;
  typedef typename VCMOnSurface::Surfel2Normals::const_iterator S2NConstIterator;
#ifdef WITH_VISU3D_QGLVIEWER
  typedef Display3DFactory<Space,KSpace>            MyDisplay3DFactory;
#endif
  const KSpace & ks = surface.container().space();
  Surfel2PointEmbedding embType = 
    embedding == 0 ? Pointels :
    embedding == 1 ? InnerSpel :
    OuterSpel;
  // KernelFunction chi( 1.0, r );
  VCMOnSurface vcm_surface( surface, embType, R, r, chi, trivial_r, Metric(), true );

  trace.beginBlock ( "Visualisation des normales." );
  VectorN lambda; // eigenvalues of chi-vcm
  SCell dummy;
#ifdef WITH_VISU3D_QGLVIEWER
  viewer << SetMode3D( dummy.className(), "Basic" );
  viewer.setFillColor( DGtal::Color( 255, 255, 255 ) );
#endif
  for ( S2NConstIterator it = vcm_surface.mapSurfel2Normals().begin(), 
          itE = vcm_surface.mapSurfel2Normals().end(); it != itE; ++it )
    {
      Surfel s = it->first;
      const VectorN & n = it->second.vcmNormal;
      const VectorN & t = it->second.trivialNormal;
#ifdef WITH_VISU3D_QGLVIEWER
      MyDisplay3DFactory::drawOrientedSurfelWithNormal( viewer, s, -n, false );
#endif
      // vcm_surface.getChiVCMEigenvalues( lambda, s );
      // double ratio = lambda[ 1 ] / ( lambda[ 0 ] + lambda[ 1 ] + lambda[ 2 ] ); // 3D !!!
      // viewer << ks.unsigns( s );
    }
  trace.endBlock();

  trace.beginBlock ( "Export de la surface." );
  std::string surfname = basename + ".off";
  std::ofstream off_output( surfname.c_str() );
  exportSteppedSurfaceAsOff( off_output, surface );
  off_output.close();
  trace.endBlock();

  trace.beginBlock ( "Export des normales par face." );
  std::string normname = basename + ".normals";
  std::ofstream normals_output( normname.c_str() );
  for ( SurfelConstIterator it = surface.begin(), itE = surface.end(); it != itE; ++it )
    {
      Surfel s = *it;
      S2NConstIterator normal_it = vcm_surface.mapSurfel2Normals().find( s );
      ASSERT( normal_it != vcm_surface.mapSurfel2Normals().end() );
      const VectorN & n = normal_it->second.vcmNormal;
      normals_output << n[ 0 ] << " " << n[ 1 ] << " " << n[ 2 ] << std::endl;
    }
  normals_output.close();
  trace.endBlock();

}


///////////////////////////////////////////////////////////////////////////////
int main( int argc, char** argv )
{
  using namespace DGtal;
  #ifdef WITH_VISU3D_QGLVIEWER
  QApplication application(argc,argv);
#endif
  
  // parse command line using CLI ----------------------------------------------
   CLI::App app;
   std::string inputFileName;
   std::string basename {"surface"};
   int thresholdMin {0};
   int thresholdMax {255};
   double R {5.0};
   double r {3.0};
   double t {3.0};
   int E {0};
   
   std::string kernel {"hat"};
   app.description("Reads a vol file, extract its surface boundary and computes its normals using VCM estimator."
                   "Example:\n" "vol2offAndNormals -i cat10.vol\n");
   app.add_option("-i,--input,1", inputFileName, "vol file (.vol, .longvol .p3d, .pgm3d and if WITH_ITK is selected: dicom, dcm, mha, mhd). For longvol, dicom, dcm, mha or mhd formats, the input values are linearly scaled between 0 and 255." )
    ->required()
    ->check(CLI::ExistingFile);
   app.add_option("--thresholdMin,-m", thresholdMin, "threshold min (excluded) to define binary shape", true);
   app.add_option("--thresholdMax,-M", thresholdMax, "threshold max (excluded) to define binary shape", true);
   app.add_option("--R-radius,-R", R, "the parameter R in the VCM.", true);
   app.add_option("--r-radius,-r", r, "the parameter r in the VCM.", true);
   app.add_option("--kernel,-k", kernel, "the function chi_r, either hat or ball.", true)
      -> check(CLI::IsMember({"ball", "hat"}));
   app.add_option("--trivial-radius,-t", t, "the parameter r for the trivial normal estimator.", true);
   app.add_option("--embedding,-E", E, "the surfel -> point embedding: 0: Pointels, 1: InnerSpel, 2: OuterSpel.")
     -> check(CLI::IsMember({0, 1, 2}));
   app.add_option("--output,-o", basename, "the output base filename (without extension)");

     
  app.get_formatter()->column_width(40);
  CLI11_PARSE(app, argc, argv);
  // END parse command line using CLI ----------------------------------------------

  KSpace ks;
  std::vector<Surfel> surfels;   // Contains the surfels if data comes from volume.
  std::vector<Point> vectPoints; // Contains the set of discrete points.

  
  trace.beginBlock( "Loading image into memory." );
  typedef DGtal::HyperRectDomain<Space> Domain;
  typedef DGtal::ImageSelector<Domain, unsigned char>::Type Image;

  Image image = GenericReader<Image>::import (inputFileName );
  Domain domain = image.domain();
  typedef functors::IntervalForegroundPredicate<Image> ThresholdedImage;
  ThresholdedImage thresholdedImage( image, thresholdMin, thresholdMax );
  Point dsize = domain.upperBound() - domain.lowerBound();
  trace.info() << "Image size = " << dsize[ 0 ]
               << "x" << dsize[ 1 ]
               << "x" << dsize[ 2 ] << std::endl;
  trace.endBlock();

  trace.beginBlock( "Extracting boundary by scanning the space. " );
  bool space_ok = ks.init( image.domain().lowerBound(),
                           image.domain().upperBound(), true );
  if (!space_ok)
    {
      trace.error() << "Error in the Khamisky space construction."<<std::endl;
      return 2;
    }
  typedef SurfelAdjacency<KSpace::dimension> MySurfelAdjacency;
  typedef KSpace::Surfel Surfel;
  typedef ImplicitDigitalSurface< KSpace, ThresholdedImage > MySurfaceContainer;
  typedef DigitalSurface< MySurfaceContainer > MyDigitalSurface;
  MySurfelAdjacency surfAdj( true ); // interior in all directions.
  Surfel bel = Surfaces<KSpace>::findABel( ks, thresholdedImage, 10000 );
  MySurfaceContainer* container = 
    new MySurfaceContainer( ks, thresholdedImage, surfAdj, bel, false  );
  MyDigitalSurface surface( container ); //acquired
  trace.info() << "Digital surface has " << surface.size() << " surfels."
               << std::endl;
  trace.endBlock();
#ifdef WITH_VISU3D_QGLVIEWER
  Viewer3D<> viewer( ks );
  viewer.setWindowTitle("Voronoi 3D viewer");
  viewer.show();
#endif
  

  if ( kernel == "hat" ) {
    typedef functors::HatPointFunction<Point,double> KernelFunction;
#ifdef WITH_VISU3D_QGLVIEWER
    computeSurfaceVCM( viewer, basename, surface, R, r, KernelFunction( 1.0, r ), t, E );
#else
    struct Vempty{}; Vempty noView;
    computeSurfaceVCM(noView, basename, surface, R, r, KernelFunction( 1.0, r ), t, E ); 
#endif

  } else if ( kernel == "ball" ) {
    typedef functors::BallConstantPointFunction<Point,double> KernelFunction;
#ifdef WITH_VISU3D_QGLVIEWER
    computeSurfaceVCM( viewer, basename, surface, R, r, KernelFunction( 1.0, r ), t, E );
#else
    struct Vempty{}; Vempty noView;
    computeSurfaceVCM( noView, basename, surface, R, r, KernelFunction( 1.0, r ), t, E );
#endif
  }
#ifdef WITH_VISU3D_QGLVIEWER
  viewer << Viewer3D<>::updateDisplay;
  return application.exec();
#else
  return 0;
#endif
  
}

